import boto3
from termcolor import colored
from datetime import datetime
import json
import sys
from pydoc import pipepager

author = {
    "name":"gl4ssesbo1",
    "twitter":"https://twitter.com/gl4ssesbo1",
    "github":"https://github.com/gl4ssesbo1",
    "blog":"https://www.pepperclipp.com/"
}

needs_creds = True

variables = {
    "SERVICE": {
        "value": "lambda",
        "required": "true",
        "description": "The service that will be used to run the module. It cannot be changed."
    },
    "FUNCTION-NAME": {
        "value": "",
        "required": "true",
        "description": "The name, ARN or partial ARN of a Function"
    },
    "FUNCTION-HANDLER": {
        "value": "",
        "required": "false",
        "description": "The name of the method within your code that Lambda calls to execute your function. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime."
    },
    "ROLE-ARN": {
        "value": "",
        "required": "false",
        "description": "The URI of the ."
    },
    "IMAGE-URI": {
        "value": "",
        "required": "false",
        "description": "The URI of the container that has the function. The function can be either a container or a zip inside a S3 bucket. So either fill this, or the S3-BUCKET and S3-KEY or ZIP File."
    },
    "ZIP-FILE": {
        "value": "",
        "required": "false",
        "description": "The zip containing the Lambda code. This file can be on the attacker's machine."
    },
    "S3-BUCKET": {
        "value": "",
        "required": "false",
        "description": "An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account."
    },
    "S3-KEY": {
        "value": "",
        "required": "false",
        "description": "The key name of the zip file that has the "
    },
    "S3-OBJECT-VERSION": {
        "value": "",
        "required": "true",
        "description": "The key name of the zip file that has the "
    },
    "RUNTIME": {
        "value": "",
        "required": "false",
        "description": "The language and version the code runs in. ('nodejs'|'nodejs4.3'|'nodejs6.10'|'nodejs8.10'|'nodejs10.x'|'nodejs12.x'|'nodejs14.x'|'java8'|'java8.al2'|'java11'|'python2.7'|'python3.6'|'python3.7'|'python3.8'|'dotnetcore1.0'|'dotnetcore2.0'|'dotnetcore2.1'|'dotnetcore3.1'|'nodejs4.3-edge'|'go1.x'|'ruby2.5'|'ruby2.7'|'provided'|'provided.al2')"
    },
    "DESCRIPTION": {
        "value": "",
        "required": "false",
        "description": "A description of the function."
    },
    "ENVIRONMENT-VARIABLES": {
        "value": "",
        "required": "false",
        "description": "File with a json of environment variables used by the function. The format is just: {\"var name\":\"var value\"}"
    },
    "INVOKE": {
        "value": "",
        "required": "false",
        "description": "File with a json of environment variables used by the function. The format is just: {\"var name\":\"var value\"}"
    }
}
description = "Create a lambda function with the code from Attacker machine, an S3 Bucket or Container Image."

aws_command = "aws lambda invoke --function-name <my-function> --payload <payload or file> -region <region> --profile <profile>"

def exploit(profile, workspace):
    now = datetime.now()
    dt_string = now.strftime("%d_%m_%Y_%H_%M_%S")
    file = "{}_ec2_enum_instances".format(dt_string)
    filename = "./workspaces/{}/{}".format(workspace, file)

    functionname = variables['FUNCTION-NAME']['value']
    funchandler = variables['FUNCTION-HANDLER']['value']
    runtime = variables['RUNTIME']['value']
    rolearn = variables['ROLE-ARN']['value']
    desc = variables['DESCRIPTION']['value']
    envvar = variables['ENVIRONMENT-VARIABLES']['value']

    imageuri = variables['IMAGE-URI']['value']

    zipname = variables['ZIP-FILE']['value']

    s3bucket = variables['S3-BUCKET']['value']
    s3key = variables['S3-KEY']['value']
    s3version = variables['S3-OBJECT-VERSION']['value']
    try:
        with open(zipname, 'rb') as file_data:
            bytes_content = file_data.read()
        print()
    except FileNotFoundError:
        return {"error": "File does not exist"}
    except:
        return {"error": str(sys.exc_info())}
    try:
        response = profile.create_function(
            FunctionName=functionname,
            Runtime=runtime,
            Role=rolearn,
            Handler='string',
            Code={
                'ZipFile': b'bytes',
                'S3Bucket': 'string',
                'S3Key': 'string',
                'S3ObjectVersion': 'string',
                'ImageUri': 'string'
            },
            Description='string',
            Timeout=123,
            MemorySize=123,
            Publish=True|False,
            VpcConfig={
                'SubnetIds': [
                    'string',
                ],
                'SecurityGroupIds': [
                    'string',
                ]
            },
            PackageType='Zip'|'Image',
            DeadLetterConfig={
                'TargetArn': 'string'
            },
            Environment={
                'Variables': {
                    'string': 'string'
                }
            },
            KMSKeyArn='string',
            TracingConfig={
                'Mode': 'Active'|'PassThrough'
            },
            Tags={
                'string': 'string'
            },
            ImageConfig={
                'EntryPoint': [
                    'string',
                ],
                'Command': [
                    'string',
                ],
                'WorkingDirectory': 'string'
            }
        )

        print(colored("------------------------------------", "yellow", attrs=['bold']))
        print(colored("FunctionName: {}".format(functionname), "yellow", attrs=['bold']))
        print(colored("------------------------------------", "yellow", attrs=['bold']))

        for key, value in response.items():
            print(
                "\t{}: {}".format(
                    colored(key, 'red'),
                    colored(value, 'blue')
                )
            )
    except:
        e = sys.exc_info()
        print(colored("[*] {}".format(e), "red"))
